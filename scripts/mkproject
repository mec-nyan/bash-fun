# vim: ft=bash

NORMAL=0
BOLD=1
DIM=2
ITALIC=3
UNDERLINE=4

BLACK=30
RED=31
GREEN=32
YELLOW=33
BLUE=34
PINK=35
CYAN=36
GREY=37
WHITE=38
DEFAULT=39


__code() {
	out='['
	while [[ $# -gt 0 ]]; do
		out+=${1}
		if [[ $# -gt 1 ]]; then
			out+=";"
		fi
		shift
	done
	out+="m"

	printf "%s" "$out"
}

__a_fruit() {
	local fruits=(🍒 🍑 🍌 🍎 🍏 🍇 🍊 🍍 🥝 🍉 🍈 🍋 🍐 🍓)
	local index=$(( RANDOM % ${#fruits[@]} ))
	echo "${fruits[$index]}"
}

__log() {
	local level=$2
	case $level in
		info)
			printf "%s  %s${1}%s\n" "$(__code $BLUE)" "$(__code $ITALIC $GREEN)" "$(__code $NORMAL)"
			;;
		# For now, default to warning
		warning|*)
			printf "%s  %s${1}%s\n" "$(__code $YELLOW)" "$(__code $ITALIC $RED)" "$(__code $NORMAL)"
			;;
	esac
}

# TODO: We may need a function that allows to select between multiple options.
# i.e. for selecting language version, etc. For now we can use the builtin "select".
__ask_yes_or_no() {
	local prompt="${1}"
	local default="${2:-no}"
	local default_msg="${3:-Using default option.}"
	local is_yes=
	local fruit=$(__a_fruit)

	printf "%s %s (y/n) (default: %s) " "${fruit}" "${prompt}" "${default}"

	local tries=0
	while read -p "> " -n 1 is_yes; do
		if [[ -z ${is_yes} ]]; then
			case "${default}" in
				y|yes|Y|Yes|YES)
					is_yes=y;;
				*)
					is_yes=n;;
			esac
			printf "   [2m%s[0m" "${default_msg}"
			break
		fi

		if [[ ${is_yes} =~ y|n ]]; then
			break
		fi

		let tries+=1
		if [[ $tries -eq 3 ]]; then
			printf "\n   [2;3mFuck it! Falling back to defaults.[0m 😑"
			break
		fi

		printf "\n[32m-> [0;3my or n?[0m "
	done

	echo

	# 'y' returns 0, otherwise 1.
	[[ ${is_yes} == 'y' ]]
}

__print_list() {
	local selected=${1}
	local options=(${2})
	local full="▪"
	local empty="▫"

	for i in "${!options[@]}"; do
		local current=$empty
		if [[ $i -eq $selected ]]; then
			current=$full
		fi
		# TODO: Colours...
		printf "   %s - %s\n" $current ${options[$i]}
	done
}

__choose() {
	local prompt=$1
	local selected=0

	printf "%s %s\n" $(__a_fruit) "$prompt"

	# Save cursor position
	echo -e -n "\E7"

	local options=($2)
	__print_list 0 "${options[*]}"

	local current=0
	local last=${#options[@]}
	while read -s -p "     [2;3mmove: j/k, toggle: space, accept: enter [0m" -n 1 option; do
		if [[ -z $option ]]; then break; fi
		case $option in
			j) ((current < (last-1))) && let current=$current+1;;
			k) ((current > 0)) && let current=$current-1;;
			*) :;;
		esac
		echo -e -n "\E8"
		__print_list $current "${options[*]}"
	done

	echo

	return $current
}

__find_command() {
	local base=$1

	compgen -c | egrep "^${base}(-[0-9]+)$" | sort -Vr | while read cmd; do
		if command -v "$cmd" &>/dev/null; then
			echo "$cmd"
			return 0
		fi
	done
	return 1
}

__mk_cpp_project() {
	local name=${1}

	__log "Making project ${name}." "info"

	local executable=false
	__ask_yes_or_no "Create main app?" "yes" "Library only."
	if [[ $? -eq 0 ]]; then
		executable=true
	fi

	local trailing_ret=false
	__ask_yes_or_no "Use trailing return?" "no" "Use traditional return."
	if [[ $? -eq 0 ]]; then
		trailing_ret=true
	fi

	# Use "iostream" or "print"
	if [[ $executable == true ]]; then
		local print_love="cout << \"I 💖 C++!\n\""
		local include="iostream"

		__ask_yes_or_no "Use std::print?" "no" "Use std::cout"
		if [[ $? -eq 0 ]]; then
			print_love="println(\"I 💖 C++!\")"
			include="print"
		fi

		# Use "using namespace std;"
		local using_namespace=
		__ask_yes_or_no "Use namespace std?" "no" "Use qualifed namespace 'std::...'"
		if [[ $? -eq 0 ]]; then
			using_namespace="using namespace std;"
		else
			print_love="std::${print_love}"
		fi
	fi

	# Single file?
	local single_file=false
	local header_file=true
	local impl_file=false

	if [[ $executable == true ]]; then
		__ask_yes_or_no "Create a single file project?" "no" "Entry point is main.cpp"
		if [[ $? -eq 0 ]]; then
			single_file=true
			header_file=false
		fi
	fi

	if [[ ${header_file} == true ]]; then
		__ask_yes_or_no "- Do you want an impl file?" "no" "Header only"
		if [[ $? -eq 0 ]]; then
			impl_file=true
		fi
	fi

	# Add test files
	local add_tests=true

	__ask_yes_or_no "Add tests?" "yes" "Adding tests folder"
	if [[ $? -ne 0 ]]; then
		add_tests=false
	fi

	# Function style
	local main_func="int main()"
	local a_func="void ${name}()"

	if [[ $trailing_ret == true ]]; then
		main_func="auto main() -> int"
		a_func="auto ${name}()"
	fi

	# Select compiler
	# If not compiler is found, default to g++ and print warning
	local compiler="g++"

	local GCC=$(__find_command "g\\+\\+")
	local CLANG=$(__find_command "clang\\+\\+")

	if [[ -n $GCC && -n $CLANG ]]; then
		local compiler_options=($GCC $CLANG)
		__choose "Select a compiler:" "${compiler_options[*]}"
		compiler=${compiler_options[$?]}
	elif [[ -n $GCC ]]; then
		compiler=$GCC
	elif [[ -n $CLANG ]]; then
		compiler=$CLANG
	else
		__log "Compiler not found." "info"
	fi

	# Select build system
	local build_system="make"

	declare -a build_opts

	if type make &>/dev/null; then 
		build_opts[${#build_opts[*]}]="make"
	fi

	if type cmake &>/dev/null; then 
		build_opts[${#build_opts[*]}]="cmake"
	fi

	if type meson &>/dev/null; then 
		build_opts[${#build_opts[*]}]="meson"
	fi

	if [[ ${#build_opts} -gt 0 ]]; then
		__choose "Select your build system:" "${build_opts[*]}"
		build_system=${build_opts[$?]}
	else
		__log "Build system not found." "warning"
	fi

	# Let's get to work!

	if ! mkdir "${name}"; then
		echo "Couldn't create directory ${name}."
		return 1
	fi

	if ! cd "${name}"; then
		echo "Couldn't cd into ${name}."
		return 1
	fi

	# Make test directory and test template
	if [[ $add_tests == true ]]; then
		test_dir="tests"
		test_file="test_${name}.cpp"

		if mkdir tests &>/dev/null; then
			touch "${test_dir}/${test_file}" &>/dev/null
		else
			echo "Failed to create test directory."
		fi

		if [[ -e ${test_dir}/${test_file} ]]; then
			cat > "tests/test_${name}.cpp" <<END
#define CATCH_CONFIG_MAIN
#include <catch2/catch.hpp>

// Add your test cases here.
TEST_CASE() {
    REQUIRE();
}
END
		else
			echo "Failed to create test template."
		fi
	fi

	# Make main cpp file
	if [[ $executable　== true ]]; then
		local main="main"
		if [[ ${single_file} == true ]]; then
			main=${name}
		fi

		cat > "${main}.cpp" <<END
// ${main}.cpp
#include <${include}>
END
	
		if [[ $using_namespace ]]; then
			cat >> "${main}.cpp" <<END
${using_namespace}
END
		fi

		cat >> "${main}.cpp" <<END

${main_func} {

	${print_love};

	return 0;

}
END
	fi

	# Headers (optional)
	# TODO: A lot (or maybe not).
	# - Trailing return?
	# - Example function? (i.e. "add_two(uint a, uint b) -> uint...")
	# - Place that example in the test file?
	# The user may have to remove all of that, so...
	# Maybe just "touch file.hpp file.cpp" is enough
	local header_name=
	local impl_name=
	if [[ ${header_file} == true ]]; then
		header_name="${name}.hpp"

		if [[ ${impl_file} == true ]]; then
			impl_name="${name}.cpp"

			cat > ${impl_name} <<END
#include "${header_name}"

${a_func} {

}
END
			cat > ${header_name} <<END

${a_func};
END
		else
			# Header only.
			cat > ${header_name} <<END

inline ${a_func} {

}
END

		fi
	fi

	# Build commands (make, cmake, meson)
	case $build_system in
		make)
			cat > Makefile <<END
IN = ${main}.cpp
OUT = ${main}.o
COMPILER_FLAGS = -std=c++23 -Wall -Werror -Wpedantic

\$(OUT): \$(IN)
	@${compiler} -o \$(OUT) \$(COMPILER_FLAGS) \$(IN) ${impl_name}

run: \$(OUT)
	@if [ -e ./\$(OUT) ]; then ./\$(OUT); fi

clean:
	@if [ -e ./\$(OUT) ]; then rm ./\$(OUT); fi
END
			# Tests anyone?
			if [[ $add_tests ]]; then
				cat >> Makefile <<END
	@if [ -e ./${test_dir}/test ]; then rm ./${test_dir}/test; fi

test:
	@${compiler} -o ${test_dir}/test \$(COMPILER_FLAGS) ${test_dir}/${test_file} ${impl_name}
	@./tests/test
END
			fi
			;;
		cmake)
			cat > CMakeLists.txt <<END
cmake_minimum_required(VERSION 3.10)
project(${name} VERSION 0.1.0)
set(CMAKE_CXX_STANDARD_REQUIRED True)
set(CMAKE_CXX_STANDARD 23)
set(CMAKE_CXX_COMPILER $(which ${compiler}))
add_executable(${name} ${name}.cpp)
END
			mkdir build
			# TODO: Add test commands in CMakeLists.txt
			;;
		meson)
			__log "Meson support: WIP" "info"
			;;
		*)
			__log "No build system selected." "info"
			;;
	esac
}

__mk_c_project() {
	local name=${1}

	# I use these two a lot. Feel free to add your own.
	__ask_yes_or_no "Include stdlib?" "no" "stdlib not included."
	local stdlib=$?
	__ask_yes_or_no "Include iso646?" "no" "iso646 not included."
	local iso646=$?

	if ! mkdir "${name}"; then
		echo "Couldn't create directory ${name}"
		return 1
	fi

	if ! cd "${name}"; then
		echo "Couldn't cd into ${name}"
		return 1
	fi

	local main="${name}.c"

	echo "// ${name}.c" > "${main}"

	[[ ${iso646} -eq 0 ]] && echo "#include <iso646.h>" >> "${main}"

	echo '#include <stdio.h>' >> "${main}"

	[[ ${stdlib} -eq 0 ]] && echo "#include <stdlib.h>" >> "${main}"

	cat >> "${name}.c" <<END

int main(void) {

	printf("I 💖 C!\n");

	return 0;

}
END

	cat > Makefile <<END
IN = ${name}.c
OUT = ${name}.o
COMPILER_FLAGS = -std=c23 -Wall -Werror -Wpedantic

\$(OUT): \$(IN)
	@gcc-14 -o \$(OUT) \$(COMPILER_FLAGS) \$(IN)

run: \$(OUT)
	@if [ -e ./\$(OUT) ]; then ./\$(OUT); fi

clean:
	@if [ -e ./\$(OUT) ]; then rm ./\$(OUT); fi
END
}

__mk_py_project() {
	local name=${1}

	if ! mkdir "${name}"; then
		echo "Couldn't create directory ${name}"
		return 1
	fi

	if ! cd "${name}"; then
		echo "Couldn't cd into ${name}"
		return 1
	fi

	cat > "${name}.py" <<END
#!/usr/bin/env python3
'''${name}.py'''


def main():
    print(love())
    return 0


def love():
    return "I 💖 Python!"


if __name__ == "__main__":
    main()
END

	cat > "test_${name}.py" <<END
#!/usr/bin/env python3
'''test_${name}.py'''

import unittest
import ${name}

class TestFunc(unittest.TestCase):

    def test_main(self):
        self.assertEqual(0, ${name}.main(), "Oops!")


if __name__ == "__main__":
    unittest.main()
END
}

__mk_lua_project() {
	local name=${1}

	if ! mkdir "${name}"; then
		echo "Couldn't create directory ${name}"
		return 1
	fi

	if ! cd "${name}"; then
		echo "Couldn't cd into ${name}"
		return 1
	fi

	cat > "${name}.lua" <<END
#!/usr/bin/env lua5
--[[
--  ${name}.lua
--]]


print "I 💖 Lua!"
END
}

__mk_go_project() {
	# TODO: Create a pkg that is not "main".
	local name=${1}
	local pkg=
	local func=
	__ask_yes_or_no "Create a main package?" "no" "Creating a regular pkg."

	case $? in
		0) pkg=main; func=main;;
		1) pkg=${name}; func=doStuff;;
	esac

	echo "Creating package ${pkg}..."

	if ! mkdir "${name}"; then
		echo "Couldn't create directory ${name}"
		return 1
	fi

	if ! cd "${name}"; then
		echo "Couldn't cd into ${name}"
		return 1
	fi

	cat > "${pkg}.go" <<END
// ${pkg}.go
package ${pkg}

import "fmt"


func ${func}() {
	fmt.Printf("I 💖 Go!\n")
}
END

	cat > "${pkg}_test.go" <<END
// ${pkg}_test.go
package ${pkg}

import "testing"


func TestSomething(t *testing.T) {
	// Given

	// When

	// Then
}
END
}

__mk_rust_project() {
	local name=${1}

	__ask_yes_or_no "Use Cargo?" "yes" \
		'Good choice! make will invoke cargo [run|test].'
	local cargo=$?

	__ask_yes_or_no "Add tests?" "yes" "Adding sample test."
	local tests=$?

	local test_fn="_ret_zero"
	local sep_file=2

	if [[ ${tests} -eq 0 ]]; then
		__ask_yes_or_no "-- Put test on a separate file?" "yes" \
			"A separate file it is..."
		sep_file=$?
	fi

	if ! mkdir "${name}"; then
		echo "Couldn't create directory ${name}"
		return 1
	fi

	if ! cd "${name}"; then
		echo "Couldn't cd into ${name}"
		return 1
	fi

	cat > "main.rs" <<END
// **/${name}/main.rs

fn main() {
	println!("I 💖 Rust!");
}
END

	if [[ ${tests} -eq 0 ]]; then
		cat >> "main.rs" <<END

fn ${test_fn}() -> i32 {
	0	
}
END
	fi

	if [[ ${sep_file} -eq 0 ]]; then
		cat >> "main.rs" <<END


#[cfg(test)]
mod tests;
END

		cat > "tests.rs" <<END
// **/${name}/tests.rs

use super::*;

#[test]
fn it_returns_zero() {
	assert_eq!(0, ${test_fn}());
}
END

	elif [[ ${sep_file} -eq 1 ]]; then
		cat >> "main.rs" <<END

#[cfg(test)]
mod tests {
	use super::*;

	#[test]
	fn it_returns_zero() {
		assert_eq!(0, ${test_fn}());
	}
}
END
	fi

	if [[ ${cargo} -eq 0 ]]; then
		# Why should I use make instead of Cargo directly?
		# When you have several Rust programs in src/bin/** you
		# need to tell cargo which one to run with "--bin name_of_bin" which
		# is a bit tedious when you are running and testing your project.
		cat > Makefile <<END
run:
	@cargo run --bin ${name}

test:
	@cargo test --bin ${name}
END
	else
		# Using rustc. I've added '.o' to the binary so you can easily
		# ignore it with "echo *.o >> .gitignore".
		# TODO: Run tests without Cargo.
		cat > Makefile <<END
IN = main.rs
OUT = ${name}.o

\$(OUT): main.rs
	@rustc -o \$(OUT) main.rs

run: \$(OUT)
	@if [ -e ./\$(OUT) ]; then ./\$(OUT); fi

clean:
	@if [ -e ./\$(OUT) ]; then rm ./\$(OUT); fi
END
	fi
}

__usage() {
	cat <<END
Usage:

	mkproject lang name

Create a project for that language and add some templates, makefiles, etc.

"lang" can be one of:

	C, c, Cpp, cpp, C++, c++, Python, python, py, Rust, rust, rs, Lua, lua, Go, go.

"name" is the name of your project.

END
}


mkproject () {
	local lang=${1}
	local name=${2}

	if [ $# -ne 2 ]; then
		__usage
		return 1
	fi

	case ${lang} in
		c|C)
			lang="c";;
		cpp|Cpp|c++|C++)
			lang="cpp";;
		py|python|Python)
			lang="python";;
		go|Go)
			lang="go";;
		rs|rust|Rust)
			lang="rust";;
		lua|Lua)
			lang="lua";;
		*)
			;;
	esac

	if [ -d "${name}" ]; then
		printf "There's already a directory named %s\n" "${name}"
		return 1
	fi

	case $lang in
		c)
			__mk_c_project ${name}
			;;
		cpp)
			__mk_cpp_project ${name}
			;;
		python)
			__mk_py_project ${name}
			;;
		go)
			__mk_go_project ${name}
			;;
		rust)
			__mk_rust_project ${name}
			;;
		lua)
			__mk_lua_project ${name}
			;;
		*)
			printf "Language '${lang}' not supported yet.\n"
			return 1
			;;
	esac

	if [ $? -eq 0 ]; then
		echo "Project ${name} created!"
	else
		echo "Couldn't create project ${name}..."
	fi
}
